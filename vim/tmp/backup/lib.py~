#!/usr/bin/env python2
# -*- codepage: utf-8 -*-
import networkx as nx
import argparse
import collections
import random
from itertools import izip_longest
import pylab


class PathError(Exception):
    pass


def dijkstra(graph, node_from, node_to, cost_function):
    """ Dijkstra algorithm
    """
    n = len(graph)  # number of nodes
    d = {node_from: 0}
    used = {}
    prev_node = {}

    for ii in xrange(n):
        current_node = filter(lambda n: not used.get(n, False), graph.nodes())

        if not current_node:
            break
        current_node = min(current_node, key=lambda x: d.get(x, 1e18))

        used[current_node] = True

        for to_node in graph:
            if to_node in graph[current_node]:
                updated_length = d.get(current_node, 1e18)
                updated_length += cost_function(graph[current_node][to_node])

                current_length = d.get(to_node, 1e18)

                if updated_length < current_length:
                    d[to_node] = updated_length
                    prev_node[to_node] = current_node

    if not node_to in d or d[node_to] >= 1e18:
        raise PathError("Can't find statisfying workpath")

    path = [node_to]
    while path[0] in prev_node:
        path = [prev_node[path[0]]] + path

    return path, d[node_to]


class ResourcesPool(object):
    """ Manages wavelengths and lifetimes
    """

    def __init__(self, total):
        self.total_wl = total
        self.allocations = []
        self.time = 0
        self.link_type = -1  # -1 - non alocated, 0 - work, 1 - backup

    def allocate_work(self, wl, lifetime):
        if not (self.link_type == -1 or self.link_type == 0):
            raise PathError("Allocation on link, with wrong type")

        used = self.get_resource_cost()
        if wl > self.total_wl - used:
            raise PathError("Cant reserve wavelengths on link")
        self.allocations += [(self.time + lifetime, wl)]
        self.link_type = 0

    def allocate_backup(self, wl, lifetime):
        if not (self.link_type == -1 or self.link_type == 1):
            raise PathError("Allocation on link with wrong type")
        used = self.get_resource_cost()
        if wl > max(self.total_wl, used):
            raise PathError("Cant reserve wavelengths on link")
        self.allocations += [(self.time + lifetime, wl)]
        self.link_type = 1

    def get_resource_cost(self):
        if self.link_type == 1:
            return max([x[1] for x in self.allocations])
        elif self.link_type == 0:
            return sum([x[1] for x in self.allocations])
        return 0

    def update_time(self, time):
        self.allocations.sort()
        self.time += time
        while self.allocations and self.allocations[0][0] <= self.time:
            self.allocations = self.allocations[1:]
        if len(self.allocations) == 0:
            self.link_type = -1

    def deallocate(self, wl, lifetime):
        self.allocations.remove((self.time + lifetime, wl))
        if len(self.allocations) == 0:
            self.link_type = -1

    def is_work_link(self):
        return self.link_type in (-1, 0)

    def is_backup_link(self):
        return self.link_type in (-1, 1)


def ford_bellman_kth(graph, node_from, node_to, cost_function, max_hops):
    """ Ford-Bellman based algorithm
        Used to search backup path with hops less than max_hops
    """
    d = [collections.defaultdict(lambda: 1e18) for i in xrange(max_hops + 1)]
    prev = [collections.defaultdict(lambda: 1e18) for i in xrange(max_hops + 1)]
    d[0][node_from] = 0
    changes = True

    # Part 1, modified Ford-Bellman
    while changes:
        changes = False
        for edge in graph.edges_iter():
            e_from, e_to = edge
            for kk in xrange(2):  # both directions
                for hc in xrange(max_hops + 1):  # hc is hops count
                    new_cost = d[hc][e_from] + cost_function(graph[e_from][e_to])
                    new_hops = hc + 1

                    if new_hops > max_hops:
                        continue
                    if new_cost < d[new_hops][e_to]:
                        # Relax througth edge
                        prev[new_hops][e_to] = e_from
                        d[new_hops][e_to] = new_cost
                        changes = True
                e_from, e_to = e_to, e_from
    # Part2, get min cost path
    res, r_hop, r_id = 1e18, -1, -1
    for i in xrange(max_hops + 1):
        if res > d[i][node_to]:
            res = d[i][node_to]
            r_hop, r_id = i, node_to
    if res >= 1e18:
        raise PathError('Cant find statisfying backup path')

    pst = r_hop
    path = [r_id]
    while path[0] in prev[r_hop]:
        path = [prev[r_hop][path[0]]] + path
        r_hop -= 1

    return path, res, pst


def workpath_cost_func(edge, required_wavelengths):
    if edge['svd_w']:
        return edge['svd_w']
    if (not edge['usable']) or (not edge['rp'].is_work_link()):
        return 1e18

    total, used = edge['wavelengths'], edge['rp'].get_resource_cost()
    if total - used < required_wavelengths:
        return 1e18  # Not enought resources

    res = (used + required_wavelengths) * edge['cost']
    res /= float(edge['wavelengths'])
    edge['svd_w'] = res
    return res


def backup_cost_func(edge, required_wavelengths):
    if edge['svd_b']:
        return edge['svd_b']
    if (not edge['usable']) or (not edge['rp'].is_backup_link()):
        return 1e18

    total, max_r = edge['wavelengths'], edge['rp'].get_resource_cost()
    if total < max(required_wavelengths, max_r):
        return 1e18  # Not enought resources

    res = 0
    alloc = [x[1] for x in  edge['rp'].allocations] + [required_wavelengths]
    max_r = max(alloc)
    for cur_m in xrange(1, max_r + 1):
        cnt = len(filter(lambda x: x >= cur_m, alloc))
        res += 1.0 / (total * cnt)
    res *= edge['cost']
    edge['svd_b'] = res
    return res


def reserve_work_wavelengths(graph, path, lifetime, wavelengths):
    for e_from, e_to in zip(path, path[1:]):
        graph[e_from][e_to]['rp'].allocate_work(wavelengths, lifetime)


def reserve_backup_wavelengths(graph, path, lifetime, wavelengths):
    for e_from, e_to in zip(path, path[1:]):
        graph[e_from][e_to]['rp'].allocate_backup(wavelengths, lifetime)


def release_wavelengths(graph, path, lifetime, wavelengths):
    for e_from, e_to in zip(path, path[1:]):
        graph[e_from][e_to]['rp'].deallocate(wavelengths, lifetime)


class ProposedSheme(object):
    """ Implementation of proposed algorithm
    """

    def __init__(self, graph):
        self.graph = nx.Graph(graph)
        for edge in self.graph.edges():
            a, b = edge
            # edge['wavelengths'] = 5
            # edge['cost'] = 123
            wl = self.graph[a][b]['wavelengths']
            self.graph[a][b]['rp'] = ResourcesPool(wl)
            self.graph[a][b]['usable'] = True

    @staticmethod
    def name():
        return "Proposed sheme"

    def connect(self, node_from, node_to, wavelengths, pst_g, lifetime):
        backups_found, real_pst = False, -1
        domain_paths, path = [], []
        total_costs = 0
        try:
            # Step 1
            costs_fn = lambda edge: workpath_cost_func(edge, wavelengths)
            path, work_cost = dijkstra(self.graph, node_from, node_to, costs_fn)
            reserve_work_wavelengths(self.graph, path, lifetime, wavelengths)
            total_costs += work_cost
            for a, b in zip(path, path[1:]):
                # Temporarry mark edge to avoid using by backup_cost_func
                self.graph[a][b]['usable'] = False

            # Step 2
            Hw = len(path) - 1  # workpath length
            H = Hw  # Non covered nodes
            node_j = 0
            Hpst = pst_g
            for k in xrange(Hw):  # k-th segment
                if backups_found:
                    break

                # TODO set usable to backups
                # TODO Hs = 1 ???
                # Domain sizes, alternative 2
                backup_found = False
                Hops_min = 1
                if k == 0 and H == 1:
                    Hops_min = 0

                for Hs in xrange(Hpst - 2, Hops_min, -1):
                    Hs = min(Hs, H)  # change m ???
                    m = (Hpst - Hs) / 2  # Max bp len
                    # Find mincost backup path less than m
                    costs_fn = lambda edge: backup_cost_func(edge, wavelengths)
                    try:
                        backup_path, cost, real_m = ford_bellman_kth(self.graph,
                            path[node_j], path[node_j + Hs], costs_fn, m)
                        total_costs += cost

                        backup_found = True
                        real_pst = max(real_pst, 2 * real_m + Hs)  # Update real pst
                        if path[node_j + Hs] == node_to:
                            backups_found = True
                        node_j += Hs - 1
                        H -= Hs - 1
                        # Reserve wavelengths
                        reserve_backup_wavelengths(self.graph, backup_path,
                                lifetime, wavelengths)
                        domain_paths.append(backup_path)
                        break
                    except:
                        pass

                if not backup_found:
                    raise PathError('Cant arrange backup')
        except BaseException, e:
            if not isinstance(e, PathError):
                raise e
        finally:
            if not backups_found:
                # Release workpaths and backups
                release_wavelengths(self.graph, path, lifetime, wavelengths)
                for path in domain_paths:
                    release_wavelengths(self.graph, path, lifetime, wavelengths)

            # Release working paths hops for use
            for e_from, e_to in self.graph.edges_iter():
                self.graph[e_from][e_to]['usable'] = True
                self.graph[e_from][e_to]['rp'].update_time(1)
                self.graph[e_from][e_to]['svd_b'] = None
                self.graph[e_from][e_to]['svd_w'] = None
            if not backups_found:
                return None
            else:
                # Ok ? return some good stuff
                return real_pst, float(total_costs) / wavelengths, domain_paths


class SharedPathProtection(object):
    def __init__(self, graph):
        self.graph = nx.Graph(graph)
        for edge in self.graph.edges():
            a, b = edge
            wl = self.graph[a][b]['wavelengths']
            self.graph[a][b]['rp'] = ResourcesPool(wl)
            self.graph[a][b]['usable'] = True

    def connect(self, node_from, node_to, wavelengths, pst_g, lifetime):
        wpath, w_cost = [], 0
        bpath, b_cost = None, 0
        total_costs = 0
        try:
            costs_fn = lambda edge: workpath_cost_func(edge, wavelengths)
            wpath, w_cost = dijkstra(self.graph, node_from, node_to, costs_fn)
            reserve_work_wavelengths(self.graph, wpath, lifetime, wavelengths)
            total_costs += w_cost
            for a, b in zip(wpath, wpath[1:]):
                # Temporarry mark edge to avoid using by backup_cost_func
                self.graph[a][b]['usable'] = False

            costs_fn = lambda edge: backup_cost_func(edge, wavelengths)
            bpath, b_cost = dijkstra(self.graph, node_from, node_to, costs_fn)
            reserve_backup_wavelengths(self.graph, bpath, lifetime, wavelengths)
            total_costs += b_cost
        finally:
            if not bpath:
                release_wavelengths(self.graph, wpath, lifetime, wavelengths)

            for a, b in self.graph.edges_iter():
                self.graph[a][b]['usable'] = True
                self.graph[a][b]['rp'].update_time(1)
                self.graph[a][b]['svd_b'] = None
                self.graph[a][b]['svd_w'] = None

            if bpath:
                pst = len(wpath) - 1 + 2 * (len(bpath) - 1)
                return pst, float(total_costs) / wavelengths
            else:
                return None

    @staticmethod
    def name():
        return "Shared path protection"


class SharedLinkProtection(object):
    def __init__(self, graph):
        self.graph = nx.Graph(graph)
        for edge in self.graph.edges():
            a, b = edge
            wl = self.graph[a][b]['wavelengths']
            self.graph[a][b]['rp'] = ResourcesPool(wl)
            self.graph[a][b]['usable'] = True

    def connect(self, node_from, node_to, wavelengths, pst_g, lifetime):
        wpath, w_cost = [], 0
        bpath, b_cost = [], 0
        total_costs = 0
        Ok = False
        pst = 0
        try:
            costs_fn = lambda edge: workpath_cost_func(edge, wavelengths)
            wpath, w_cost = dijkstra(self.graph, node_from, node_to, costs_fn)
            reserve_work_wavelengths(self.graph, wpath, lifetime, wavelengths)
            total_costs += w_cost
            for a, b in zip(wpath, wpath[1:]):
                # Temporarry mark edge to avoid using by backup_cost_func
                self.graph[a][b]['usable'] = False

            costs_fn = lambda edge: backup_cost_func(edge, wavelengths)
            for a, b in zip(wpath, wpath[1:]):
                path, b_cost = dijkstra(self.graph, a, b, costs_fn)
                reserve_backup_wavelengths(self.graph, path,
                        lifetime, wavelengths)
                total_costs += b_cost
                bpath.append([path])
                pst = max(pst, 1 + 2 * (len(path) - 1))
            Ok = True
        finally:
            if not Ok:
                release_wavelengths(self.graph, wpath, lifetime, wavelengths)
                for path in bpath:
                    release_wavelengths(self.graph, path, lifetime, wavelengths)

            for a, b in self.graph.edges_iter():
                self.graph[a][b]['usable'] = True
                self.graph[a][b]['rp'].update_time(1)
                self.graph[a][b]['svd_b'] = None
                self.graph[a][b]['svd_w'] = None

            if Ok:
                return pst, float(total_costs) / wavelengths
            else:
                return None

    @staticmethod
    def name():
        return "Shared link protection"

# Constants
T_f, T_node, T_p = 1.0, 0.0, 1.0
# Shemes
lib_shemes = [ProposedSheme, SharedPathProtection, SharedLinkProtection]


def pst_to_pathlen(pst):
    return (pst - T_f - 2 * T_node + T_p) / (T_node + T_p)


def pathlen_to_pst(plen):
    return (T_f + 2 * T_node - T_p) + plen * (T_node + T_p)


class ShemeTester(object):
    def __init__(self, sheme):
        self.sh = sheme
        self.total_pst = 0
        self.total_cost = 0
        self.total_blocks = 0
        self.total_pst_ok = 0
        self.total_runs = 0
        self.pst_stat = []
        self.pst_stat_real = []
        self.cost_stat = []

    def conn(self, a, b, pst, wl, lifetime):
        npst = pst_to_pathlen(pst)
        res = self. sh.connect(a, b, wl, npst, lifetime)
        self.total_runs += 1
        self.pst_stat += [pst]
        self.pst_stat_real += [0]
        self.cost_stat += [(0 if len(self.cost_stat) == 0 else self.cost_stat[-1])]

        if res == None:
            self.total_blocks += 1
        else:
            rpst = pathlen_to_pst(res[0])
            self.pst_stat_real[-1] = rpst
            self.total_pst += rpst
            self.total_cost += res[1]
            self.cost_stat[-1] = res[1]
            if res[0] <= npst:
                self.total_pst_ok += 1

    def save_stats(self, fig):
        pylab.subplot(211)
        p1 = pylab.plot(xrange(0, self.total_runs), self.pst_stat, 'b-')
        p2 = pylab.plot(xrange(0, self.total_runs), self.pst_stat_real, 'g-')
        pylab.title(self.sh.name())
        pylab.xlabel('Path #')
        pylab.ylabel('PST')
        pylab.legend((p1[0], p2[0]), ('requested', 'real'), 'upper center')

        pylab.subplot(212)
        p1 = pylab.plot(xrange(0, self.total_runs), self.cost_stat, 'b-')
        pylab.title(self.sh.name())
        pylab.xlabel('Path #')
        pylab.ylabel('cost')
        pylab.legend((p1[0],), ('perwave cost',), 'upper center')

    def get_info(self):
        nruns = self.total_runs - self.total_blocks + 1e-8
        return [float(self.total_blocks) / (self.total_runs + 1e-8),
                float(self.total_pst) / nruns,
                float(self.total_cost) / nruns,
                float(self.total_pst_ok) / nruns * 100]

    def __str__(self):
        res = """{}
{} runs.
Blocking rate: {}
Average pst: {}
Average cost per wavelength: {}
Satisfaction: {}%"""
        nruns = self.total_runs - self.total_blocks
        return res.format(self.sh.name(),
                self.total_runs,
                float(self.total_blocks) / self.total_runs,
                float(self.total_pst) / nruns,
                float(self.total_cost) / nruns,
                float(self.total_pst_ok) / nruns * 100)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('file', help='graph file')
    args = parser.parse_args()

    with open(args.file, 'r') as f:
        graph = nx.Graph()
        data = f.read().split()
        data = list(izip_longest(*(iter(data),) * 4))
        for n_fr, n_to, wl, cost in data:
            graph.add_edge(n_fr, n_to)
            graph[n_fr][n_to]['wavelengths'] = int(wl)
            graph[n_fr][n_to]['cost'] = int(cost)

        shemes = [ProposedSheme(graph), SharedPathProtection(graph)]
        shemes = map(ShemeTester, shemes)
        fig = pylab.figure()
        nx.draw(graph, ax=fig.add_subplot(len(shemes) + 2, 1, 1))

        cnt = 1000
        for t in xrange(cnt):
            if t % 100 == 0:
                print t
            node_from, node_to = random.sample(graph.nodes(), 2)
            pst = random.randint(3, 8)
            lifetime = random.randint(1, 10)
            wavelengths = random.randint(1, 32)

            for sh in shemes:
                sh.conn(node_from, node_to, pst, wavelengths, lifetime)

        for index, sh in enumerate(shemes):
            sh.save_stats(fig)
            print sh, '\n'


if __name__ == '__main__':
    #profile.run('main()')
    main()
    pylab.show()
